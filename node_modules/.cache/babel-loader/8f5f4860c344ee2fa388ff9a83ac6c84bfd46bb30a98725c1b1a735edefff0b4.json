{"ast":null,"code":"\"use strict\";\n\nconst utils = require(\"./utils\");\nfunction passThroughRequest(mockAdapter, config) {\n  // Axios v0.17 mutates the url to include the baseURL for non hostnames\n  // but does not remove the baseURL from the config\n  let baseURL = config.baseURL;\n  if (baseURL && !/^https?:/.test(baseURL)) {\n    baseURL = undefined;\n  }\n\n  // Axios pre 1.2\n  if (typeof mockAdapter.originalAdapter === \"function\") {\n    return mockAdapter.originalAdapter(config);\n  }\n  return mockAdapter.axiosInstanceWithoutInterceptors(Object.assign({}, config, {\n    baseURL,\n    //  Use the original adapter, not the mock adapter\n    adapter: mockAdapter.originalAdapter,\n    // The request transformation runs on the original axios handler already\n    transformRequest: [],\n    transformResponse: []\n  }));\n}\nasync function handleRequest(mockAdapter, config) {\n  let url = config.url || \"\";\n  // TODO we're not hitting this `if` in any of the tests, investigate\n  if (config.baseURL && url.substr(0, config.baseURL.length) === config.baseURL) {\n    url = url.slice(config.baseURL.length);\n  }\n  delete config.adapter;\n  mockAdapter.history.push(config);\n  const handler = utils.findHandler(mockAdapter.handlers, config.method, url, config.data, config.params, config.headers && config.headers.constructor.name === \"AxiosHeaders\" ? Object.assign({}, config.headers.toJSON()) : config.headers, config.baseURL);\n  if (handler) {\n    if (handler.replyOnce) {\n      utils.purgeIfReplyOnce(mockAdapter, handler);\n    }\n    if (handler.passThrough) {\n      // passThrough handler\n      return passThroughRequest(mockAdapter, config);\n    } else {\n      return utils.settle(config, handler.response, getEffectiveDelay(mockAdapter, handler));\n    }\n  } else {\n    // handler not found\n    switch (mockAdapter.onNoMatch) {\n      case \"passthrough\":\n        return passThroughRequest(mockAdapter, config);\n      case \"throwException\":\n        throw utils.createCouldNotFindMockError(config);\n      default:\n        return utils.settle(config, {\n          status: 404\n        }, mockAdapter.delayResponse);\n    }\n  }\n}\nfunction getEffectiveDelay(adapter, handler) {\n  return typeof handler.delay === \"number\" ? handler.delay : adapter.delayResponse;\n}\nmodule.exports = handleRequest;","map":{"version":3,"names":["utils","require","passThroughRequest","mockAdapter","config","baseURL","test","undefined","originalAdapter","axiosInstanceWithoutInterceptors","Object","assign","adapter","transformRequest","transformResponse","handleRequest","url","substr","length","slice","history","push","handler","findHandler","handlers","method","data","params","headers","constructor","name","toJSON","replyOnce","purgeIfReplyOnce","passThrough","settle","response","getEffectiveDelay","onNoMatch","createCouldNotFindMockError","status","delayResponse","delay","module","exports"],"sources":["/Users/gavinappi-fy/healthcare-chat-frontend/node_modules/axios-mock-adapter/src/handle_request.js"],"sourcesContent":["\"use strict\";\nconst utils = require(\"./utils\");\n\nfunction passThroughRequest (mockAdapter, config) {\n  // Axios v0.17 mutates the url to include the baseURL for non hostnames\n  // but does not remove the baseURL from the config\n  let baseURL = config.baseURL;\n  if (baseURL && !/^https?:/.test(baseURL)) {\n    baseURL = undefined;\n  }\n\n  // Axios pre 1.2\n  if (typeof mockAdapter.originalAdapter === \"function\") {\n    return mockAdapter.originalAdapter(config);\n  }\n\n  return mockAdapter.axiosInstanceWithoutInterceptors(Object.assign({}, config, {\n    baseURL,\n    //  Use the original adapter, not the mock adapter\n    adapter: mockAdapter.originalAdapter,\n    // The request transformation runs on the original axios handler already\n    transformRequest: [],\n    transformResponse: []\n  }));\n}\n\nasync function handleRequest(mockAdapter, config) {\n  let url = config.url || \"\";\n  // TODO we're not hitting this `if` in any of the tests, investigate\n  if (\n    config.baseURL &&\n    url.substr(0, config.baseURL.length) === config.baseURL\n  ) {\n    url = url.slice(config.baseURL.length);\n  }\n\n  delete config.adapter;\n  mockAdapter.history.push(config);\n\n  const handler = utils.findHandler(\n    mockAdapter.handlers,\n    config.method,\n    url,\n    config.data,\n    config.params,\n    (config.headers && config.headers.constructor.name === \"AxiosHeaders\")\n      ? Object.assign({}, config.headers.toJSON())\n      : config.headers,\n    config.baseURL\n  );\n\n  if (handler) {\n    if (handler.replyOnce) {\n      utils.purgeIfReplyOnce(mockAdapter, handler);\n    }\n\n    if (handler.passThrough) {\n      // passThrough handler\n      return passThroughRequest(mockAdapter, config);\n    } else {\n      return utils.settle(\n        config,\n        handler.response,\n        getEffectiveDelay(mockAdapter, handler)\n      );\n    }\n  } else {\n    // handler not found\n    switch (mockAdapter.onNoMatch) {\n      case \"passthrough\":\n        return passThroughRequest(mockAdapter, config);\n      case \"throwException\":\n        throw utils.createCouldNotFindMockError(config);\n      default:\n        return utils.settle(\n          config,\n          { status: 404 },\n          mockAdapter.delayResponse\n        );\n    }\n  }\n}\n\nfunction getEffectiveDelay(adapter, handler) {\n  return typeof handler.delay === \"number\" ? handler.delay : adapter.delayResponse;\n}\n\nmodule.exports = handleRequest;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}